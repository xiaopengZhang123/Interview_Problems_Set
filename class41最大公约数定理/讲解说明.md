# 说明
## 辗转相除法
1.辗转相除法其实就是欧几里得法，他的步骤是 有两个数a,b,这两个数比如说是50 30，那么第一步就是c=a%b,然后a=b,b=c,就这三步，写成循环就是
```
int gcd(int a,int b){
   int c=1;
   while(c!=0){
    c=a%b;
    a=b;
    b=c;
   } 
   //最后a就是我们求的最大公约数
}
```
也可以写成是递归的方式
```
int gcd(int a,int b){
    return b==0?a:(gcd(b,a%b));
}
```
通过这样的简单几步,我们就可以得到a,b的最大公约数,然后问题是这样的

```
一个正整数如果能被 a 或 b 整除，那么它是神奇的。
给定三个整数 n , a , b ，返回第n个神奇的数字。因为答案可能很大，所以返回答案 对 1e9+7 取模 后的值。
```

首先,什么叫做神奇数字,神奇数字就是假如说 $a,b$这两个数,就说a=2,b=3,那么神奇数就是可以整除a,b的数,比如说2(2可以整除a,然后3也是一个神奇数,这样当n=1时,我们就说第一个神奇数是2,第二个神奇数是3),这个问题其实没有什么思路,暴力做法也不一定会想到

问题是,我们要在哪一块区间里面搜索呢,这个其实就有点小tips了,首先还是假设```a=2```,那么实际上,满足x%a的数的话,我们就可以求得x最小是$2n$就可以,就是说第100个满足神奇数的值一定在200这个区间内,这是好理解的,但确实得仔细想一想,好好推理一番,而且我们可以更加严格得说,因为在这200个数中,一定也还有3的倍数,所以我们的搜索区间就是
```
Math.min(a,b)*n
```
这个区间,足以有n个神奇数,所以这就是我们的搜索区间\
所以,我们就可以使用暴力的方法
```
for(int i=1;i<=Math.min(a,b)*n;i++){
    if(i%a==0||i%b==0){
        cnt++;
    }
}
```
这个暴力算法会超时,我们可以例如容斥原理和二分查找
```
还是上面的gcd函数,因为之前a,b的最小公倍数不算两次,只能算一次,那么给定一个区间n,那么满足是2,3 神奇数的个数就是 n/a+n/b-n/(ab最小公倍数),这个其实好理解,就是一个文氏图
```
那么怎么优化呢,这很明显是一个有序的区间内进行搜索,那么我们就可以使用二分查找
```
standard binary search template 

int l=0,r=Math.min(a,b),m=0;
int lcm=(a*b)/gcd(a,b);//Least Common Multiple,最小公倍数,实际上,最小公倍数就是a/gcd(a,b)*b,a和与b相同的最大因子相除,那么剩下来的就是与b互质的a的最小因子,两者相乘就是a,b的最小公倍数

while(l<=r){
    m=l+(r-l)/2;
    if(m/a+m/b-m/lcm>=n){
        ans=m;
        r=m-1;//让我想起了印度小哥mycodeschool的那个二分法
    }else{
        l=m+1;
    }
}
return res

```
这个就是所有的分析